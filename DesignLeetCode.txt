Problem: 
Question bank store thousands of programming questions. Users should be able to write, compile and submit code against test cases and recieve feedback immediately.
The code submitted by users should be persisted 
Every week there is a contest where thousands of users concurrently submit solutions to leetcode problems. WRITE/READ
There is a leaderboard which shows the ranking of participants in real time during the 2 hours. WRITE/READ
After the contest ends, the leaderboard becoems a frozen historical representation of the contests. READ

Functional Requiremnts: 
READ: view programming question and question bank, and solution of the users, compilation of the programming question, testing the code against the test cases to get immediate feedback
WRITE: write a solution to the programming question which should persist. Thousands of users concurrently submit solutions to their 
UPDATE: User should be able to compete in a ranked competetion with real time updates.

Non Functional Requiremnts:
Thousands of people concurrently  => high Concurrency
Immediate feedback + real time updates => low latency 
persistance => system must be durable and safe
implicit => secure.


Solution: 

High level design:
View problem:
Client: Frontend application sends an http get request command
Problem Service: Service has two methods one for list all problems and one for get problem by name
Database: Stores problme data: id, problem name, description with constraints, difficulty, example solutions

Submit Solution: 
Things to think about: a monolith microservice would not fit this as there is a high concurrency non functional requirement. The service that recieves the submission should not be same service that checks if the code is correct in real time. That service should not be the same as the code compiling service
We have three services submit solution, solution compiler, solution accuracy checker. We also utilize a message queue here. The code evaluation service will see spikes during the start and end of the competetion
Code evaluation validates the submission and sends a message with the userid, problemid, and the solution to the message queue. 
As the user can send malicous code to run in our checker, the execute microservice is seperate

Code execution system design options:
API Gateway: although it has low latency as there is not much between the API layer and the code execution not good because malicous code can potentiallly access server data, one users code could consume all resources implying they could crah the entire servers
Virtual Machines: this is okay as it has isolation of processes of each code execution and it is felxible meaning it can run in many different os, and it has good security. but it is very resource intensive and costly to implement, slow to start and hard to manage
Container: packages dependencies together with a host OS kernel that is lightweight with consistent environments. This solves many problems from the virtual mahcine as it is lightweight, fast to startup and has a consistent environemnt which is easier to manage. Although it has lower security as it shares the same os kernel in contrast format so less isolation 
The serverless function is similar to the container but it has slow startup time this is implemented using a caas. It also comes with inherent problems with using the cloud like vendor lock, and limits to usage and cost depending on the cloud service


Client: Frontend applicatin sends an http create request command
Problem Service: Service has one method where you submit a solution to the problme 

