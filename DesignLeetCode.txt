Problem: 
Question bank store thousands of programming questions. Users should be able to write, compile and submit code against test cases and recieve feedback immediately.
The code submitted by users should be persisted 
Every week there is a contest where thousands of users concurrently submit solutions to leetcode problems. WRITE/READ
There is a leaderboard which shows the ranking of participants in real time during the 2 hours. WRITE/READ
After the contest ends, the leaderboard becoems a frozen historical representation of the contests. READ

Functional Requiremnts: 
READ: view programming question and question bank, and solution of the users, compilation of the programming question, testing the code against the test cases to get immediate feedback
WRITE: write a solution to the programming question which should persist. Thousands of users concurrently submit solutions to their 
UPDATE: User should be able to compete in a ranked competetion with real time updates.

Non Functional Requiremnts:
Thousands of people concurrently  => high Concurrency
Immediate feedback + real time updates => low latency 
persistance => system must be durable and safe
implicit => secure.


Solution: 

High level design:
View problem:
Client: Frontend application sends an http get request command
Problem Service: Service has two methods one for list all problems and one for get problem by name
Database: Stores problme data: id, problem name, description with constraints, difficulty, example solutions

Submit Solution: 
Things to think about: a monolith microservice would not fit this as there is a high concurrency non functional requirement. The service that recieves the submission should not be same service that checks if the code is correct in real time. That service should not be the same as the code compiling service
We have three services submit solution, solution compiler, solution accuracy checker. We also utilize a message queue here. The code evaluation service will see spikes during the start and end of the competetion
Code evaluation validates the submission and sends a message with the userid, problemid, and the solution to the message queue. 
As the user can send malicous code to run in our checker, the execute microservice is seperate

Code execution system design options:
API Gateway: although it has low latency as there is not much between the API layer and the code execution not good because malicous code can potentiallly access server data, one users code could consume all resources implying they could crah the entire servers
Virtual Machines: this is okay as it has isolation of processes of each code execution and it is felxible meaning it can run in many different os, and it has good security. but it is very resource intensive and costly to implement, slow to start and hard to manage
Container: packages dependencies together with a host OS kernel that is lightweight with consistent environments. This solves many problems from the virtual mahcine as it is lightweight, fast to startup and has a consistent environemnt which is easier to manage. Although it has lower security as it shares the same os kernel in contrast format so less isolation 
The serverless function is similar to the container but it has slow startup time this is implemented using a caas. It also comes with inherent problems with using the cloud like vendor lock, and limits to usage and cost depending on the cloud service


Client: Frontend applicatin sends an http create request command
Problem Service: Service has one method where you submit a solution to the problem 

Async results retreival 
How do we avoid connection timeouts during the programming contests when multiple users are accessign the application at the same time. To solve this issue we can user async result retreival.
This is when the code submission microservice immediately returns the submission results and then the client checks back for accuracy.
In summary we get:
instant response from code submission microservice 
then the client periodically checks the solutions accuracy checker microservice to check how the submission was recieved 
When the clients recieves a repsonse it returns back to user user

WHy use polling instead of serversend events or websockets:
Websockets need bidirectional communication and that is a bottleneck to the memory manaagement 
Seversend reposnses are one way and require long lived connections which could be 10k open connections at the same time.
Polling is stateless so it is optimal in this case, the cost of polling is negligeble compared to websockets or serversent reponses.


How do we maintian the leaderboard:
Due to the everchanging data a simple sql query wont work as users will not be able to accurately see thier spot on the leaderboard
Solution: in-memmory sorted radis cache which uses skip lists => O(log n + 50) as we just check all of the peices of data(top 50 or wtv leaderboard needs)not O(n log n) as we do not have to sort the data after every insertion
skip list: dynamic data structure which maintains data in a sorted order instead of having constant sorting
After code evaluation service finishes grading the code it sends it to the contest microservice and this allows the contest microservice to recalculate the score relative to the contest and then send the new submission to the Redis
cache and then send the submission to update the redis cache 



